I initially started with C, but I didn't feel like reinventing a lot of the machinery I would usually have (string slices, dynamic arrays, etc.) so I switched to Python to just get part 1 over with. Python has a lot of built-in features like dictionaries that made implementing the algorithm nearly trivial.

I chose Rust for my second language because it seemed like the most interesting language on the list. Rust's stdlib comes with hashmaps and lists that made translating the code from Python to Rust pretty trivial -- it's very hacky but it works well enough for the autograder. Despite the ease of writing it I'm very sure my Rust code was nowhere near optimal (which I'll mention again later).

I have a soft spot for Haskell and other functional programming languages since I used to use them a lot in the past, and I had a lot of fun implementing the challenge in Haskell. Data.Graph had some nice helpers for working with graphs/trees which simplified things a bit. The big challenge was figuring out how to convert the input into the Graph data type that was required by the library and then how to extract the data back into printable form. It was definitely the most difficult to get working as my thought process is pretty imperative but I also thought it was the most fun.

COOL was horrible -- I thought at most it would take 2-3 hours and I'm pretty sure I spent far longer than that. The algorithm was pretty similar, creating a dependency and reverse dependency list and then navigating through them using a DFS. I created a string List datatype and then created a Dict that mapped strings to Lists. My solution was incredibly non performant, I didn't even bother for it to finish running the austen test case. I'm glad I wrote it since I'm very familiar with the language now but I am glad to not have to write something significant in COOL ever again.

My goal with the test case was to create an input that would strain the performance of the system. I generated the complete graph of 250 elements and wrote them to a file, then ran them through all my programs. Interestingly, Python ran the fastest, followed by Rust, and with Haskell pretty far in last. My guess is that the allocations caused by my Rust code caused it to slow down significantly. I'm not surprised that Haskell performed the slowest -- it's not a language made for performance at all -- but Python performing the best was definitely surprising.